require "db"
require "uuid"
require "active-model"
require "./database"
require "./changefeed"
require "./persistence"
require "./extensions"
require "./query"
require "./table"
require "./errors"
require "./validators/*"

module PgORM
  abstract class Base < ActiveModel::Model
    include ActiveModel::Validation
    include ActiveModel::Callbacks

    include Associations
    include Persistence
    extend Query
    include Table
    include Validators
    extend ChangeReceiver

    TABLES = [] of String

    macro inherited
      class_getter primary_key : Symbol = :id
      class_getter auto_generate_id : Bool = true
      macro finished
        {% unless @type.abstract? %}
        __process_table__
        {% end %}
      end
    end

    # Always returns this record's primary key value, even when the primary key
    # isn't named `id`
    abstract def id

    # Same as `id` but may return `nil` when the record hasn't been saved
    # instead of raising.
    abstract def id?

    @[JSON::Field(ignore: true)]
    @[YAML::Field(ignore: true)]
    @extra_attributes : Hash(String, PgORM::Value)?

    protected def extra_attributes=(@extra_attributes : Hash(String, Value))
    end

    protected def extra_attributes : Hash(String, PgORM::Value)
      @extra_attributes ||= {} of String => PgORM::Value
    end

    def primary_key
      @@primary_key
    end

    macro __customize_orm__
      {% if HAS_KEYS[0] && !PERSIST.empty? %}
          check_converters_if_any
          __set_primary_key__
          __create_db_initializer__
      {% end %}
    end

    def_equals attributes, changed_attributes

    macro default_primary_key(name, autogenerated = true, converter = nil, **tags)
      attribute {{name.var}} : {{name.type.resolve}}, mass_assignment: {{!autogenerated}},
            primary_key: true, autogenerated: {{autogenerated}}, converter: {{converter}}, es_type: "keyword" {% unless tags.empty? %}, {{**tags}} {% end %}
    end

    # Sets the primary key for this model.
    private macro __set_primary_key__
    {% pk_name = nil
       pk_type = nil %}

    {% for name, opts in PERSIST %}
     {%
       type = opts[:type_signature].resolve
       opts[:autogenerated] = (opts[:tags] && opts[:tags][:autogenerated] == true)

       if (tags = opts[:tags]) && (tags[:primary_key] == true)
         pk_name = name
         pk_type = type
       end
     %}
    {% end %}

     {% if pk_name %}
        alias PrimaryKeyType = {{pk_type}} # {{parse_type("#{pk_type}?")}}

        @@primary_key = {{pk_name.id.symbolize}}
        @@auto_generate_id = {{PERSIST[pk_name][:autogenerated]}}

        {% if pk_type.nilable? && pk_name.id.symbolize == :id %}
          def id? : {{pk_type}}?
          {{pk_name.id}}
          end
        {% end %}
        {% unless pk_name.id.symbolize == :id %}
            def id : {{pk_type}}
              {{pk_name.id}}
            end

            def id? : {{pk_type}}?
              {{pk_name.id}}?
            end

            protected def id=(value : {{pk_type}})
              self.{{pk_name.id}} = value
            end
        {% end %}
        {% if %w(Int8 Int16 Int32 Int64).includes?(pk_type.stringify) %}
        @[AlwaysInline]
        protected def set_primary_key_after_create(value : Int)
          self.{{pk_name.id}} = {{pk_type}}.new(value)
        end
      {% else %}
        @[AlwaysInline]
        protected def set_primary_key_after_create(value : {{pk_type}})
          self.{{pk_name.id}} = value
        end
      {% end %}

      @[AlwaysInline]
      protected def set_primary_key_after_create(value)
        raise "Expected primary key type : #{PrimaryKeyType}, received: #{value}, type: #{typeof(value)}"
      end
     {% else %}
        # Default primary key
        alias PrimaryKeyType = Int64
        attribute id : Int64, mass_assignment: false, primary_key: true, autogenerated: true, es_type: "keyword"

        def id? : Int64?
          @id
        end
        @[AlwaysInline]
        protected def set_primary_key_after_create(value : Int)
          @id = Int64.new(value)
        end
        @[AlwaysInline]
        protected def set_primary_key_after_create(value)
          raise "Expected primary key type : #{PrimaryKeyType}, received value: #{value} of type: #{typeof(value)}"
        end
     {% end %}
    end

    private macro __create_db_initializer__
      def self.from_rs(%rs : ::DB::ResultSet)
        %objs = Array(self).new
        %rs.each do
          %objs << self.new(%rs)
        end
        %objs
      ensure
        %rs.close
      end
      def self.new(rs : ::DB::ResultSet)
        %extra_attributes = nil
        {% pk_defined = false %}
        {% for key, opts in PERSIST %}
          {% if (tags = opts[:tags]) && (tags[:primary_key] == true) %}
            {% pk_defined = true %}
          {% end %}
        {% end %}
        {% for key, opts in PERSIST %}
           var_{{key}} = ActiveModel::Model::None.new
        {% end %}

        {% unless pk_defined %} var_id = ActiveModel::Model::None.new {% end %}

        rs.each_column do |%column_name|
          case %column_name
            {% for key, opts in PERSIST %}
            when {{key.stringify}}
              var_{{key}} =
                {% if opts[:converter] %}
                  {{opts[:converter]}}.from_rs(rs)
                {% elsif opts[:klass] < Array %}
                  rs.read({{opts[:klass]}})
                {% elsif opts[:klass] < Set %}
                  rs.read(Array({{opts[:klass].type_vars.join(' ').id}})).to_set
                {% elsif opts[:klass].union_types.reject(&.==(Nil)).first < Enum %}
                  {% if opts[:klass].nilable? %}
                     if (v = rs.read(Int32?))
                      {{opts[:klass].union_types.reject(&.==(Nil)).first}}.from_value(v)
                     else
                        nil
                     end
                  {% else %}
                  {{opts[:klass]}}.from_value(rs.read(Int32))
                  {% end %}
                {% elsif (::PgORM::Value).union_types.includes?(opts[:klass].union_types.reject(&.==(Nil)).first) == false %}
                   {{opts[:klass].union_types.reject(&.==(Nil)).first}}.from_json(JSON::Any.new(rs.read(JSON::PullParser{% if opts[:klass].nilable? %}?{% end %})).to_json)
                {% elsif opts[:klass] < Int %}
                  {{opts[:klass]}}.new(rs.read(Int))
                {% else %}
                  rs.read({{opts[:klass]}})
                {% end %}
            {% end %}
            {% unless pk_defined %}
            when "id"
              var_id = rs.read(PrimaryKeyType)
            {% end %}
            else
              %extra_attributes ||= {} of String => PgORM::Value
              %extra_attributes[%column_name] = rs.read(PgORM::Value)
          end
        end

        %result = new(
          {% unless pk_defined %}
            id: var_id,
          {% end %}
          {% for key, opts in PERSIST %}
            {{key}}: var_{{key}},
          {% end %}
        )

        %result.extra_attributes = %extra_attributes if %extra_attributes
        %result.new_record = false
        %result.clear_changes_information
        %result
      end

      protected def load_attributes(rs : ::DB::ResultSet)
        {% pk_defined = false %}
        {% for key, opts in PERSIST %}
          {% if (tags = opts[:tags]) && (tags[:primary_key] == true) %}
            {% pk_defined = true %}
          {% end %}
        {% end %}

        {% begin %}
        rs.each_column do |%column_name|
            case %column_name
              {% for key, opts in PERSIST %}
              when {{key.stringify}}
                @{{key}} =
                  {% if opts[:converter] %}
                    {{opts[:converter]}}.from_rs(rs)
                  {% elsif opts[:klass] < Array %}
                    rs.read({{opts[:klass]}})
                  {% elsif opts[:klass] < Set %}
                  rs.read(Array({{opts[:klass].type_vars.join(' ').id}})).to_set
                  {% elsif opts[:klass].union_types.reject(&.==(Nil)).first < Enum %}
                    {% if opts[:klass].nilable? %}
                      if (v = rs.read(Int32?))
                        {{opts[:klass].union_types.reject(&.==(Nil)).first}}.from_value(v)
                      else
                          nil
                      end
                    {% else %}
                      {{opts[:klass]}}.from_value(rs.read(Int32))
                    {% end %}
                 {% elsif (::PgORM::Value).union_types.includes?(opts[:klass].union_types.reject(&.==(Nil)).first) == false %}
                    {{ opts[:klass].union_types.reject(&.==(Nil)).first }}.from_json(JSON::Any.new(rs.read(JSON::PullParser{% if opts[:klass].nilable? %}?{% end %})).to_json)
                 {% elsif opts[:klass] < Int %}
                    {{opts[:klass]}}.new(rs.read(Int))
                 {% else %}
                    rs.read({{opts[:klass]}})
                  {% end %}
              {% end %}
              {% unless pk_defined %}
              when "id"
                @id = rs.read(PrimaryKeyType)
              {% end %}
              else
                extra_attributes[%column_name] = rs.read(PgORM::Value)
            end
        end
        {% end %}
      end

      # :nodoc:
      def [](attr : Symbol)
        persistent_attributes[attr]
      end

      # :nodoc:
      def []=(attr : Symbol, value)
        case attr
          {% for key, opts in FIELDS %}
        when {{key.symbolize}}
         {% ivar_type = opts[:klass] %}
         {% if (tags = opts[:tags]) && (tags[:primary_key]) && !ivar_type.nilable? %}
           {% ivar_type = parse_type("#{ivar_type}?") %}
         {% end %}
          @{{key}} = value.as?({{ivar_type}})
          {% end %}
        else
          raise PgORM::Error.new("no such attribute: #{self.class.name}[:#{attr}]")
        end
      end

      def persistent_attributes
        {
          {% for name, opts in PERSIST %}
            {% if opts[:klass] < Array && !opts[:converter] %}
            :{{name}} => PQ::Param.encode_array(@{{name}} || ([] of {{opts[:klass]}})),
            {% elsif opts[:klass] < Set %}
            :{{name}} => PQ::Param.encode_array((@{{name}} || (Set({{opts[:klass]}}).new)).to_a),
            {% elsif opts[:klass].union_types.reject(&.==(Nil)).first < Enum && !opts[:converter] %}
            :{{name}} => @{{name}}.try &.value,
            {% elsif (::PgORM::Value).union_types.includes?(opts[:klass].union_types.reject(&.==(Nil)).first) %}
            :{{name}} => @{{name}},
            {% elsif opts[:converter] %}
              {% if opts[:converter] && opts[:converter].resolve.class.methods.map(&.name.id).includes?(:to_rs.id) %}
                :{{name}} => {{opts[:converter]}}.to_rs(@{{name}}),
              {% else %}
                :{{name}} => {{opts[:converter]}}.to_json(@{{name}}),
              {% end %}
            {% else %}
            :{{name}} => @{{name}}.to_json,
            {% end %}
          {% end %}
        } {% if PERSIST.empty? %} of Nil => Nil {% end %}
      end

      def changed_persist_attributes
        all = persistent_attributes
        {% for name, index in PERSIST.keys %}
          all.delete(:{{name}}) unless @{{name}}_changed
        {% end %}
        all
      end

      # :nodoc:
      @@change_block : Array(ChangeFeed({{@type.id}})) = Array(ChangeFeed({{@type.id}})).new

      # Changefeed at row (if `id` passed) or whole table level.
      # Returns a `ChangeFeed` instance which can be used to invoke async callbacks via `on` or
      # use blocking `Iterator` via `each` method.
      def self.changes(id : PrimaryKeyType{% unless PrimaryKeyType.nilable? %}?{% end %} = nil) : ChangeFeed
        feed = ChangeFeed({{@type.id}}).new(id,self)
        @@change_block << feed
        PgORM::Database.listen_change_feed(table_name, self) if @@change_block.size == 1
        feed
      end

      # :nodoc:
      def self.stop_changefeed(receiver : ChangeFeed)
        @@change_block.delete(receiver)
        PgORM::Database.stop_change_feed(table_name) if @@change_block.empty?
      end

      # :nodoc:
      def self.changefeed (event : PgORM::ChangeReceiver::Event, change : String)
        model = from_trusted_json(change)
        model.destroyed = true if event.deleted?
        @@change_block.each {|cb| spawn{cb.on_event(event, model)}}
      end

      def self.on_error(err : Exception | IO::Error)
        @@change_block.each {|cb| cb.on_error(err)}
      end

      class ChangeFeed(T)

        # Represents a Changefeed Change, where `event` represents CRUD operation and value is the model
        record(Change(T),
          value : T,
          event : PgORM::ChangeReceiver::Event,
        ) do

          def created?
            event.created?
          end

          def updated?
            event.updated?
          end

          def deleted?
            event.deleted?
          end
        end

        include Iterator(Change(T))

        @callback : (Change(T) -> Nil)? = nil

        def initialize(@id : PrimaryKeyType{% unless PrimaryKeyType.nilable? %}?{% end %} = nil, @parent : T.class = T.class)
          @channel = Channel(Change(T)).new
        end

       # Method expects a block which will get invoked with `Change(T)` parameter on change events received from `EventBus`
       def on(&block : Change(T) -> Nil)
          @callback = block
       end

        def stop
          @channel.close
          @parent.stop_changefeed(self)
        end

        def next
          val = @channel.receive
          if val.nil?
            Iterator::Stop::INSTANCE
          else
            val.not_nil!
          end
        rescue Channel::ClosedError
          Iterator::Stop::INSTANCE
        end

        # :nodoc:
        def on_event(evt : PgORM::ChangeReceiver::Event, model : T)
          if (@id.nil? || @id == model.id)
            change = Change(T).new(model, evt)
            @callback.try &.call(change)
            # discard previous event (if any), so that we only keep copy of latest
            # received event.
            spawn do
              select
                when @channel.send(change)
                else @channel.receive?
              end rescue nil
            end
          end
        end

        # :nodoc:
        def on_error(err : Exception | IO::Error)
            stop rescue nil
            raise err
        end
      end
    end

    macro __nilability_validation__
      # Validate that all non-nillable fields have values.
      def validate_nilability
        {% if HAS_KEYS[0] && !PERSIST.empty? %}
          {% for name, opts in PERSIST %}
            {% if !opts[:klass].nilable? && !opts[:autogenerated] %}
              validation_error({{name.symbolize}}, "should not be nil" ) if @{{name.id}}.nil?
            {% end %}
          {% end %}
        {% end %}
      end
    end

    private macro check_converters_if_any
      {% for name, opts in PERSIST %}
        {% if (converter = opts[:converter]) && (!converter.resolve.class.methods.map(&.name.id).includes?(:from_rs.id)) %}
          {% raise "Converter '#{converter.id}' provided for attribute #{name}, doesn't support method for parsing resultset" %}
        {% end %}
      {% end %}
    end
  end
end
